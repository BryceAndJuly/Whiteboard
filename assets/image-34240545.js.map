{"version":3,"file":"image-34240545.js","sources":["../../src/data/image.ts"],"sourcesContent":["import decodePng from \"png-chunks-extract\";\nimport tEXt from \"png-chunk-text\";\nimport encodePng from \"png-chunks-encode\";\nimport { stringToBase64, encode, decode, base64ToString } from \"./encode\";\nimport { EXPORT_DATA_TYPES, MIME_TYPES } from \"../constants\";\nimport { blobToArrayBuffer } from \"./blob\";\n\n// -----------------------------------------------------------------------------\n// PNG\n// -----------------------------------------------------------------------------\n\nexport const getTEXtChunk = async (\n  blob: Blob,\n): Promise<{ keyword: string; text: string } | null> => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n  const metadataChunk = chunks.find((chunk) => chunk.name === \"tEXt\");\n  if (metadataChunk) {\n    return tEXt.decode(metadataChunk.data);\n  }\n  return null;\n};\n\nexport const encodePngMetadata = async ({\n  blob,\n  metadata,\n}: {\n  blob: Blob;\n  metadata: string;\n}) => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n\n  const metadataChunk = tEXt.encode(\n    MIME_TYPES.excalidraw,\n    JSON.stringify(\n      await encode({\n        text: metadata,\n        compress: true,\n      }),\n    ),\n  );\n  // insert metadata before last chunk (iEND)\n  chunks.splice(-1, 0, metadataChunk);\n\n  return new Blob([encodePng(chunks)], { type: MIME_TYPES.png });\n};\n\nexport const decodePngMetadata = async (blob: Blob) => {\n  const metadata = await getTEXtChunk(blob);\n  if (metadata?.keyword === MIME_TYPES.excalidraw) {\n    try {\n      const encodedData = JSON.parse(metadata.text);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\n          \"type\" in encodedData &&\n          encodedData.type === EXPORT_DATA_TYPES.excalidraw\n        ) {\n          return metadata.text;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error: any) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n\n// -----------------------------------------------------------------------------\n// SVG\n// -----------------------------------------------------------------------------\n\nexport const encodeSvgMetadata = async ({ text }: { text: string }) => {\n  const base64 = await stringToBase64(\n    JSON.stringify(await encode({ text })),\n    true /* is already byte string */,\n  );\n\n  let metadata = \"\";\n  metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;\n  metadata += `<!-- payload-version:2 -->`;\n  metadata += \"<!-- payload-start -->\";\n  metadata += base64;\n  metadata += \"<!-- payload-end -->\";\n  return metadata;\n};\n\nexport const decodeSvgMetadata = async ({ svg }: { svg: string }) => {\n  if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {\n    const match = svg.match(\n      /<!-- payload-start -->\\s*(.+?)\\s*<!-- payload-end -->/,\n    );\n    if (!match) {\n      throw new Error(\"INVALID\");\n    }\n    const versionMatch = svg.match(/<!-- payload-version:(\\d+) -->/);\n    const version = versionMatch?.[1] || \"1\";\n    const isByteString = version !== \"1\";\n\n    try {\n      const json = await base64ToString(match[1], isByteString);\n      const encodedData = JSON.parse(json);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\n          \"type\" in encodedData &&\n          encodedData.type === EXPORT_DATA_TYPES.excalidraw\n        ) {\n          return json;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error: any) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n"],"names":["getTEXtChunk","blob","metadataChunk","decodePng","blobToArrayBuffer","chunk","tEXt","encodePngMetadata","metadata","chunks","MIME_TYPES","encode","encodePng","decodePngMetadata","encodedData","EXPORT_DATA_TYPES","decode","error","encodeSvgMetadata","text","base64","stringToBase64","decodeSvgMetadata","svg","match","versionMatch","isByteString","json","base64ToString"],"mappings":"uGAWa,MAAAA,EAAe,MAC1BC,GACsD,CAEtD,MAAMC,EADSC,EAAU,IAAI,WAAW,MAAMC,EAAkBH,CAAI,CAAC,CAAC,EACzC,KAAMI,GAAUA,EAAM,OAAS,MAAM,EAClE,OAAIH,EACKI,EAAK,OAAOJ,EAAc,IAAI,EAEhC,IACT,EAEaK,EAAoB,MAAO,CACtC,KAAAN,EACA,SAAAO,CACF,IAGM,CACE,MAAAC,EAASN,EAAU,IAAI,WAAW,MAAMC,EAAkBH,CAAI,CAAC,CAAC,EAEhEC,EAAgBI,EAAK,OACzBI,EAAW,WACX,KAAK,UACH,MAAMC,EAAO,CACX,KAAMH,EACN,SAAU,EAAA,CACX,CACH,CAAA,EAGK,OAAAC,EAAA,OAAO,GAAI,EAAGP,CAAa,EAE3B,IAAI,KAAK,CAACU,EAAUH,CAAM,CAAC,EAAG,CAAE,KAAMC,EAAW,GAAA,CAAK,CAC/D,EAEaG,EAAoB,MAAOZ,GAAe,CAC/C,MAAAO,EAAW,MAAMR,EAAaC,CAAI,EACpC,IAAAO,GAAA,YAAAA,EAAU,WAAYE,EAAW,WAC/B,GAAA,CACF,MAAMI,EAAc,KAAK,MAAMN,EAAS,IAAI,EACxC,GAAA,EAAE,YAAaM,GAAc,CAE/B,GACE,SAAUA,GACVA,EAAY,OAASC,EAAkB,WAEvC,OAAOP,EAAS,KAEZ,MAAA,IAAI,MAAM,QAAQ,CAC1B,CACO,OAAA,MAAMQ,EAAOF,CAAW,QACxBG,EAAY,CACnB,cAAQ,MAAMA,CAAK,EACb,IAAI,MAAM,QAAQ,CAC1B,CAEI,MAAA,IAAI,MAAM,SAAS,CAC3B,EAMaC,EAAoB,MAAO,CAAE,KAAAC,KAA6B,CACrE,MAAMC,EAAS,MAAMC,EACnB,KAAK,UAAU,MAAMV,EAAO,CAAE,KAAAQ,CAAM,CAAA,CAAC,EACrC,EAAA,EAGF,IAAIX,EAAW,GACH,OAAAA,GAAA,qBAAqBE,EAAW,UAAU,OAC1CF,GAAA,6BACAA,GAAA,yBACAA,GAAAY,EACAZ,GAAA,uBACLA,CACT,EAEac,EAAoB,MAAO,CAAE,IAAAC,KAA2B,CACnE,GAAIA,EAAI,SAAS,gBAAgBb,EAAW,UAAU,EAAE,EAAG,CACzD,MAAMc,EAAQD,EAAI,MAChB,uDAAA,EAEF,GAAI,CAACC,EACG,MAAA,IAAI,MAAM,SAAS,EAErB,MAAAC,EAAeF,EAAI,MAAM,gCAAgC,EAEzDG,IADUD,GAAA,YAAAA,EAAe,KAAM,OACJ,IAE7B,GAAA,CACF,MAAME,EAAO,MAAMC,EAAeJ,EAAM,CAAC,EAAGE,CAAY,EAClDZ,EAAc,KAAK,MAAMa,CAAI,EAC/B,GAAA,EAAE,YAAab,GAAc,CAE/B,GACE,SAAUA,GACVA,EAAY,OAASC,EAAkB,WAEhC,OAAAY,EAEH,MAAA,IAAI,MAAM,QAAQ,CAC1B,CACO,OAAA,MAAMX,EAAOF,CAAW,QACxBG,EAAY,CACnB,cAAQ,MAAMA,CAAK,EACb,IAAI,MAAM,QAAQ,CAC1B,CACF,CACM,MAAA,IAAI,MAAM,SAAS,CAC3B"}