{"version":3,"sources":["service-worker.ts"],"names":["self","__WB_MANIFEST","filter","entry","test","url"],"mappings":"yBAgCiB,swJAAK,cAAc,QAAO,SAAC,GAC1C,OAAQ,sBAAsB,KACX,kBAAV,EAAqB,EAAQ,EAAM,IAE9C","file":"service-worker.js","sourceRoot":"","sourcesContent":["///\n/* eslint-disable no-restricted-globals */\n\n// This service worker can be customized!\n// See https://developers.google.com/web/tools/workbox/modules\n// for the list of available Workbox modules, or add any other\n// code you'd like.\n// You can also remove this file if you'd prefer not to use a\n// service worker, and the Workbox build step will be skipped.\n\nimport { clientsClaim } from \"workbox-core\";\nimport { ExpirationPlugin } from \"workbox-expiration\";\nimport { precacheAndRoute, createHandlerBoundToURL } from \"workbox-precaching\";\nimport { registerRoute } from \"workbox-routing\";\nimport { CacheFirst, StaleWhileRevalidate } from \"workbox-strategies\";\n\ndeclare const self: ServiceWorkerGlobalScope;\n\n// clientsClaim();\n\n// Precache assets generated by your build process.\n//\n// Their URLs are injected into the __WB_MANIFEST during build (by workbox).\n//\n// This variable must be present somewhere in your service worker file,\n// even if you decide not to use precaching. See https://cra.link/PWA.\n//\n// We don't want to precache i18n files so we filter them out\n// (normally this should be configured in a webpack workbox plugin, but we don't\n// have access to it in CRA) â€” this is because all users will use at most\n// one or two languages, so there's no point fetching all of them. (They'll\n// be cached as you load them.)\nconst manifest = self.__WB_MANIFEST.filter((entry) => {\n  return !/locales\\/[\\w-]+json/.test(\n    typeof entry === \"string\" ? entry : entry.url,\n  );\n});\n\n// precacheAndRoute(manifest);\n\n// Set up App Shell-style routing, so that all navigation requests\n// are fulfilled with your index.html shell. Learn more at\n// https://developer.chrome.com/docs/workbox/app-shell-model/\n//\n// below is copied verbatim from CRA@5\n// const fileExtensionRegexp = new RegExp(\"/[^/?]+\\\\.[^/]+$\");\n// registerRoute(\n//   // Return false to exempt requests from being fulfilled by index.html.\n//   ({ request, url }: { request: Request; url: URL }) => {\n//     // If this isn't a navigation, skip.\n//     if (request.mode !== \"navigate\") {\n//       return false;\n//     }\n\n//     // If this is a URL that starts with /_, skip.\n//     if (url.pathname.startsWith(\"/_\")) {\n//       return false;\n//     }\n\n//     // If this looks like a URL for a resource, because it contains\n//     // a file extension, skip.\n//     if (url.pathname.match(fileExtensionRegexp)) {\n//       return false;\n//     }\n\n//     // Return true to signal that we want to use the handler.\n//     return true;\n//   },\n//   createHandlerBoundToURL(`${process.env.PUBLIC_URL}/index.html`),\n// );\n\n// Cache resources that aren't being precached\n// -----------------------------------------------------------------------------\n\n// registerRoute(\n//   new RegExp(\"/fonts.css\"),\n//   new StaleWhileRevalidate({\n//     cacheName: \"fonts\",\n//     plugins: [\n//       // Ensure that once this runtime cache reaches a maximum size the\n//       // least-recently used images are removed.\n//       new ExpirationPlugin({ maxEntries: 50 }),\n//     ],\n//   }),\n// );\n\n// since we serve fonts from, don't forget to append new ?v= param when\n// updating fonts (glyphs) without changing the filename\n// registerRoute(\n//   new RegExp(\"/.+.(ttf|woff2|otf)\"),\n//   new CacheFirst({\n//     cacheName: \"fonts\",\n//     plugins: [\n//       // Ensure that once this runtime cache reaches a maximum size the\n//       // least-recently used images are removed.\n//       new ExpirationPlugin({\n//         maxEntries: 50,\n//         // 90 days\n//         maxAgeSeconds: 7776000000,\n//       }),\n//     ],\n//   }),\n// );\n\n// registerRoute(\n//   new RegExp(\"/locales\\\\/[\\\\w-]+json\"),\n//   // Customize this strategy as needed, e.g., by changing to CacheFirst.\n//   new CacheFirst({\n//     cacheName: \"locales\",\n//     plugins: [\n//       // Ensure that once this runtime cache reaches a maximum size the\n//       // least-recently used images are removed.\n//       new ExpirationPlugin({\n//         maxEntries: 50,\n//         // 30 days\n//         maxAgeSeconds: 2592000000,\n//       }),\n//     ],\n//   }),\n// );\n\n// -----------------------------------------------------------------------------\n\n// self.addEventListener(\"fetch\", (event) => {\n//   if (\n//     event.request.method === \"POST\" &&\n//     event.request.url.endsWith(\"/web-share-target\")\n//   ) {\n//     return event.respondWith(\n//       (async () => {\n//         const formData = await event.request.formData();\n//         const file = formData.get(\"file\");\n//         const webShareTargetCache = await caches.open(\"web-share-target\");\n//         await webShareTargetCache.put(\"shared-file\", new Response(file));\n//         return Response.redirect(\"/?web-share-target\", 303);\n//       })(),\n//     );\n//   }\n// });\n\n// // This allows the web app to trigger skipWaiting via\n// // registration.waiting.postMessage({type: 'SKIP_WAITING'})\n// self.addEventListener(\"message\", (event) => {\n//   if (event.data && event.data.type === \"SKIP_WAITING\") {\n//     self.skipWaiting();\n//   }\n// });\nexport {}"]}